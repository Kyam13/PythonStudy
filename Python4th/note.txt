

デコレータの実装例
・functoolsのlru_cacheを使って１６までのフィボナッチ数列を出力している
from functools import lru_cache # 引数に紐づけて関数の結果をキャッシュできるモジュールー＞同じ引数で関数が呼び出された時２買い目以降は関数の呼び他しを行わず、保存しておいた戻り値を使うようになる
#＠高階関数
@lru_cache(maxsize=None)
def fib(n):
    if n < 2:
        return n
    return fib(n-1) + fib(n-2)


print([fib(n) for n in range(16)])

実行結果
$ python fibonachi.py                                                                                            [~/Python/PythonStudy/Python4th]
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]


pythonでクラスを使う
オブジェクト指向開発＝＞出来合いの部品を組みあわせてプログラムを作成していくこと

オブジェクトはデータと振る舞いを知っているもの　振る舞いをメソッドと呼ぶ

クラスとは何か
  オブジェクトの設計図
  オブジェクトがどのような性質をもっていてどのような振る舞いをするのかということをコードに書いてクラスという形にかえる

クラスからインスタンスを生成　インスタンスとはクラスから作ったオブジェクトをインスタンスと呼ぶ

from decimal import Decimal <- 標準ライブラリのクラス

d = Decumal(10) <- Decimalクラスのインスタンス（オブジェクト）を生成
print(d.sqrt()) <- Decimalクラスのsqrtというメソッドを使っている　この場合　√１０を計算している

自分でクラスを作成するとき
class クラス名:
  処理

アトリビュート
class MyClass:
  pass <-何もしないという処理

i = MyClass() MyClassクラスのインスンタンス生成

i.value = 5　＜＜＜ーー  この時valueという名のアトリビュートが生成されかつそれに数値が代入された。

これはインスタンスという名の設計図に書かれていない変数を勝手に書き込むことができる。

メソッド定義
class クラス名:
  def メソッド名(selfを含む引数): <- 上で言うiと言うのがselfに相当する。
    メソッド処理

_(アンダースコア)の意味
  メソッド名で__init__ ()などいろいろ見て来たと思うがこいつ自体は意味があって、アンダースコアを二つつけることによってクラスの外部からそのメソッドのアトリビュートにアクセスできなくなります。
  一個では書き換えてはいけないという警告的な意味を持つ。このような外部から利用できなくすることをカプセル化と呼ぶ
